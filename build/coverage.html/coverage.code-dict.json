{"/home/travis/build/npmtest/node-npmtest-loadtest/test.js":"/* istanbul instrument in package npmtest_loadtest */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-loadtest/lib.npmtest_loadtest.js":"/* istanbul instrument in package npmtest_loadtest */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_loadtest = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_loadtest = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-loadtest/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-loadtest && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_loadtest */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_loadtest\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_loadtest.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_loadtest.rollup.js'] =\n            local.assetsDict['/assets.npmtest_loadtest.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_loadtest.__dirname +\n                    '/lib.npmtest_loadtest.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-loadtest/loadtest/index.js":"'use strict';\n\n/**\n * Package contains a load test script and a test server.\n * (C) 2013 Alex Fernández.\n */\n\n\n// requires\nvar loadtest = require('./lib/loadtest.js');\nvar testserver = require('./lib/testserver.js');\n\n// exports\nexports.loadTest = loadtest.loadTest;\nexports.startServer = testserver.startServer;\n\n","/home/travis/build/npmtest/node-npmtest-loadtest/loadtest/lib/loadtest.js":"'use strict';\n\n/**\n * Load Test a URL, website or websocket.\n * (C) 2013 Alex Fernández.\n */\n\n\n// requires\nrequire('prototypes');\nvar Log = require('log');\nvar http = require('http');\nvar https = require('https');\nvar testing = require('testing');\nvar httpClient = require('./httpClient.js');\nvar websocket = require('./websocket.js');\nvar timing = require('./timing.js');\n\n// globals\nvar log = new Log('info');\n\n// constants\nvar SHOW_INTERVAL_MS = 5000;\n\n// init\nhttp.globalAgent.maxSockets = 1000;\nhttps.globalAgent.maxSockets = 1000;\n\n\n/**\n * Run a load test.\n * Options is an object which may have:\n *\t- url: mandatory URL to access.\n *\t- concurrency: how many concurrent clients to use.\n *\t- maxRequests: how many requests to send\n *\t- maxSeconds: how long to run the tests.\n *\t- cookies: a string or an array of strings, each with name:value.\n *\t- headers: a map with headers: {key1: value1, key2: value2}.\n *\t- method: the method to use: POST, PUT. Default: GET, what else.\n *\t- body: the contents to send along a POST or PUT request.\n *\t- contentType: the MIME type to use for the body, default text/plain.\n *\t- requestsPerSecond: how many requests per second to send.\n *\t- agentKeepAlive: if true, then use connection keep-alive.\n *\t- debug: show debug messages.\n *\t- quiet: do not log any messages.\n *\t- indexParam: string to replace with a unique index.\n *\t- insecure: allow https using self-signed certs.\n * An optional callback will be called if/when the test finishes.\n */\nexports.loadTest = function(options, callback)\n{\n\tif (!options.url)\n\t{\n\t\tlog.error('Missing URL in options');\n\t\treturn;\n\t}\n\toptions.concurrency = options.concurrency || 1;\n\tif (options.requestsPerSecond)\n\t{\n\t\toptions.requestsPerSecond = options.requestsPerSecond / options.concurrency;\n\t}\n\tif (options.debug)\n\t{\n\t\tlog.level = Log.DEBUG;\n\t}\n\tif (!options.url.startsWith('http://') && !options.url.startsWith('https://') && !options.url.startsWith('ws://'))\n\t{\n\t\tlog.error('Invalid URL %s, must be http://, https:// or ws://', options.url);\n\t\treturn;\n\t}\n\tif (callback && !('quiet' in options))\n\t{\n\t\toptions.quiet = true;\n\t}\n\n\tif (options.url.startsWith('ws:'))\n\t{\n\t\tif (options.requestsPerSecond)\n\t\t{\n\t\t\tlog.error('\"requestsPerSecond\" not supported for WebSockets');\n\t\t}\n\t}\n\n\tvar operation = new Operation(options, callback);\n\toperation.start();\n\treturn operation;\n};\n\n/**\n * Used to keep track of individual load test Operation runs.\n *\n * @type {number}\n */\nvar operationInstanceIndex = 0;\n\n/**\n * A load test operation.\n */\nvar Operation = function(options, callback)\n{\n\t// self-reference\n\tvar self = this;\n\n\t// attributes\n\tself.running = true;\n\tself.latency = null;\n\tvar clients = {};\n\tvar requests = 0;\n\tvar showTimer;\n\tvar stopTimeout;\n\n\tself.instanceIndex = operationInstanceIndex++;\n\n\t/**\n\t * Start the operation.\n\t */\n\tself.start = function()\n\t{\n\t\tself.latency = new timing.Latency(options);\n\t\tstartClients();\n\t\tif (options.maxSeconds)\n\t\t{\n\t\t\tstopTimeout = setTimeout(self.stop, options.maxSeconds * 1000);\n\t\t}\n\t\tshowTimer = new timing.HighResolutionTimer(SHOW_INTERVAL_MS, self.latency.showPartial);\n\t};\n\n\t/**\n\t * Call after each operation has finished.\n\t */\n\tself.callback = function(error, result, next)\n\t{\n\t\trequests += 1;\n\t\tif (options.maxRequests)\n\t\t{\n\t\t\tif (requests == options.maxRequests)\n\t\t\t{\n\t\t\t\tself.stop();\n\t\t\t}\n\t\t\tif (requests > options.maxRequests)\n\t\t\t{\n\t\t\t\tlog.debug('Should have no more running clients');\n\t\t\t}\n\t\t}\n\t\tif (self.running && next)\n\t\t{\n\t\t\tnext();\n\t\t}\n\t\tif (options.statusCallback)\n\t\t{\n\t\t\toptions.statusCallback(error, result, self.latency.getResults());\n\t\t}\n\t};\n\n\t/**\n\t * Start a number of measuring clients.\n\t */\n\tfunction startClients()\n\t{\n\t\tvar url = options.url;\n\t\tfor (var index = 0; index < options.concurrency; index++)\n\t\t{\n\t\t\tif (options.indexParam)\n\t\t\t{\n\t\t\t\toptions.url = url.replaceAll(options.indexParam, index);\n\n\t\t\t\tif(options.body)\n\t\t\t\t{\n\t\t\t\t\tvar strBody = JSON.stringify(options.body);\n\t\t\t\t\tstrBody = strBody.replaceAll(options.indexParam, index);\n\t\t\t\t\toptions.body = JSON.parse(strBody);\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t\tvar constructor = httpClient.create;\n\t\t\tif (options.url.startsWith('ws:'))// TODO: || options.url.startsWith('wss:'))\n\t\t\t{\n\t\t\t\tconstructor = websocket.create;\n\t\t\t}\n\t\t\tvar client = constructor(self, options);\n\t\t\tclients[index] = client;\n\t\t\tif (!options.requestsPerSecond)\n\t\t\t{\n\t\t\t\tclient.start();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// start each client at a random moment in one second\n\t\t\t\tvar offset = Math.floor(Math.random() * 1000);\n\t\t\t\tsetTimeout(client.start, offset);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Stop clients.\n\t */\n\tself.stop = function()\n\t{\n\t\tif (showTimer)\n\t\t{\n\t\t\tshowTimer.stop();\n\t\t}\n\t\tif (stopTimeout)\n\t\t{\n\t\t\tclearTimeout(stopTimeout);\n\t\t}\n\t\tself.running = false;\n\n\t\tObject.keys(clients).forEach(function(index) {\n\t\t\tclients[index].stop();\n\t\t});\n\t\tif (callback)\n\t\t{\n\t\t\tvar result = self.latency.getResults();\n\t\t\tresult.instanceIndex = this.instanceIndex;\n\t\t\tcallback(null, result);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tself.latency.show();\n\t\t}\n\t};\n};\n\n/**\n * A load test with max seconds.\n */\nfunction testMaxSeconds(callback)\n{\n\tvar options = {\n\t\turl: 'http://localhost:7357/',\n\t\tmaxSeconds: 0.1,\n\t\tconcurrency: 1,\n\t\tquiet: true,\n\t};\n\texports.loadTest(options, callback);\n}\n\n\n/**\n * A load test with max seconds.\n */\nfunction testWSEcho(callback)\n{\n\tvar options = {\n\t\turl: 'ws://localhost:7357/',\n\t\tmaxSeconds: 0.1,\n\t\tconcurrency: 1,\n\t\tquiet: true,\n\t};\n\texports.loadTest(options, callback);\n}\n\n\n/**\n * Run all tests.\n */\nexports.test = function(callback)\n{\n\ttesting.run([testMaxSeconds, testWSEcho], callback);\n};\n\n// run tests if invoked directly\nif (__filename == process.argv[1])\n{\n\texports.test(testing.show);\n}\n\n","/home/travis/build/npmtest/node-npmtest-loadtest/loadtest/lib/httpClient.js":"'use strict';\n\n/**\n * Load Test a URL, website or websocket.\n * (C) 2013 Alex Fernández.\n */\n\n\n// requires\nrequire('prototypes');\nvar testing = require('testing');\nvar urlLib = require('url');\nvar http = require('http');\nvar https = require('https');\nvar websocket = require('websocket');\nvar Log = require('log');\nvar timing = require('./timing.js');\nvar headers = require('./headers.js');\n\n// globals\nvar log = new Log('info');\n\n\n/**\n * Create a new HTTP client.\n * Seem parameters below.\n */\nexports.create = function(operation, params)\n{\n\treturn new HttpClient(operation, params);\n};\n\n/**\n * A client for an HTTP connection.\n * Operation is an object which has these attributes:\n *\t- latency: a variable to measure latency.\n *\t- running: if the operation is running or not.\n * Params is an object with the same options as exports.loadTest.\n */\nfunction HttpClient(operation, params)\n{\n\t// self-reference\n\tvar self = this;\n\n\t// attributes\n\tvar requestTimer;\n\tvar options;\n\tvar generateMessage;\n\n\tfunction identity(arg)\n\t{\n\t\treturn function() { return arg; };\n\t}\n\n\t// init\n\tinit();\n\n\t/**\n\t * Init options and message to send.\n\t */\n\tfunction init()\n\t{\n\t\toptions = urlLib.parse(params.url);\n\t\toptions.headers = {};\n\t\tif (params.headers)\n\t\t{\n\t\t\toptions.headers = params.headers;\n\t\t}\n\t\tif (params.cert && params.key)\n\t\t{\n\t\t\toptions.cert = params.cert;\n\t\t\toptions.key = params.key;\n\t\t}\n\t\toptions.agent = false;\n\t\tif (params.agentKeepAlive)\n\t\t{\n\t\t\tvar KeepAlive = (options.protocol == 'https:') ? require('agentkeepalive').HttpsAgent : require('agentkeepalive');\n\t\t\tvar maxSockets = 10;\n\t\t\tif (params.requestsPerSecond)\n\t\t\t{\n\t\t\t\tmaxSockets += Math.floor(params.requestsPerSecond);\n\t\t\t}\n\t\t\toptions.agent = new KeepAlive({\n\t\t\t\tmaxSockets: maxSockets,\n\t\t\t\tmaxKeepAliveRequests: 0, // max requests per keepalive socket, default is 0, no limit\n\t\t\t\tmaxKeepAliveTime: 30000  // keepalive for 30 seconds\n\t\t\t});\n\t\t}\n\t\tif (params.method)\n\t\t{\n\t\t\toptions.method = params.method;\n\t\t}\n\t\tif (params.body)\n\t\t{\n\t\t\tif (typeof params.body == 'string')\n\t\t\t{\n\t\t\t\tlog.debug('Received string body');\n\t\t\t\tgenerateMessage = identity(params.body);\n\t\t\t}\n\t\t\telse if (typeof params.body == 'object')\n\t\t\t{\n\t\t\t\tlog.debug('Received JSON body');\n\t\t\t\tgenerateMessage = identity(params.body);\n\t\t\t}\n\t\t\telse if (typeof params.body == 'function')\n\t\t\t{\n\t\t\t\tlog.debug('Received function body');\n\t\t\t\tgenerateMessage = params.body;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog.error('Unrecognized body: %s', typeof params.body);\n\t\t\t}\n\t\t\toptions.headers['Content-Type'] = params.contentType || 'text/plain';\n\t\t}\n\t\tif (params.cookies)\n\t\t{\n\t\t\tif (Array.isArray(params.cookies))\n\t\t\t{\n\t\t\t\toptions.headers.Cookie =  params.cookies.join('; ');\n\t\t\t}\n\t\t\telse if (typeof params.cookies == 'string')\n\t\t\t{\n\t\t\t\toptions.headers.Cookie = params.cookies;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tconsole.error('Invalid cookies %j, please use an array or a string', params.cookies);\n\t\t\t}\n\t\t}\n\t\theaders.addUserAgent(options.headers);\n\t\tif (params.secureProtocol) {\n\t\t\toptions.secureProtocol = params.secureProtocol;\n\t\t}\n\t\tlog.debug('Options: %j', options);\n\t}\n\n\t/**\n\t * Start the HTTP client.\n\t */\n\tself.start = function()\n\t{\n\t\tif (!params.requestsPerSecond)\n\t\t{\n\t\t\treturn self.makeRequest();\n\t\t}\n\t\tvar interval = 1000 / params.requestsPerSecond;\n\t\trequestTimer = new timing.HighResolutionTimer(interval, self.makeRequest);\n\t};\n\n\t/**\n\t * Stop the HTTP client.\n\t */\n\tself.stop = function()\n\t{\n\t\tif (requestTimer)\n\t\t{\n\t\t\trequestTimer.stop();\n\t\t}\n\t};\n\n\t/**\n\t * Make a single request to the server.\n\t */\n\tself.makeRequest = function()\n\t{\n\t\tif (!operation.running)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tvar id = operation.latency.start();\n\t\tvar requestFinished = getRequestFinisher(id);\n\t\tvar lib = http;\n\t\tif (options.protocol == 'https:')\n\t\t{\n\t\t\tlib = https;\n\t\t}\n\t\tif (options.protocol == 'ws:')\n\t\t{\n\t\t\tlib = websocket;\n\t\t}\n\t\t// Disable certificate checking\n\t\tif (params.insecure === true)\n\t\t{\n\t\t\tprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';\n\t\t}\n\t\tvar request, message;\n\t\tif (generateMessage)\n\t\t{\n\t\t\tmessage = generateMessage(id);\n\t\t\tif (typeof message === 'object')\n\t\t\t{\n\t\t\t\tmessage = JSON.stringify(message);\n\t\t\t}\n\t\t\toptions.headers['Content-Length'] = Buffer.byteLength(message);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdelete options.headers['Content-Length'];\n\t\t}\n\t\tif (typeof params.requestGenerator == 'function')\n\t\t{\n\t\t\trequest = params.requestGenerator(params, options, lib.request, getConnect(id, requestFinished));\n\t\t}\n\t\telse\n\t\t{\n\t\t\trequest = lib.request(options, getConnect(id, requestFinished));\n\t\t}\n\t\tif (params.hasOwnProperty('timeout'))\n\t\t{\n\t\t\tvar timeout = parseInt(params.timeout);\n\t\t\tif (!timeout)\n\t\t\t{\n\t\t\t\tlog.error('Invalid timeout %s', params.timeout);\n\t\t\t}\n\t\t\trequest.setTimeout(timeout, function()\n\t\t\t{\n\t\t\t\trequestFinished('Connection timed out');\n\t\t\t});\n\t\t}\n\t\tif (message)\n\t\t{\n\t\t\trequest.write(message);\n\t\t}\n\t\trequest.on('error', function(error)\n\t\t{\n\t\t\trequestFinished('Connection error: ' + error.message);\n\t\t});\n\t\trequest.end();\n\t};\n\n\t/**\n\t * Get a function that finishes one request and goes for the next.\n\t */\n\tfunction getRequestFinisher(id)\n\t{\n\t\treturn function(error, result)\n\t\t{\n\t\t\tvar errorCode = null;\n\t\t\tif (error)\n\t\t\t{\n\t\t\t\tlog.debug('Connection %s failed: %s', id, error);\n\t\t\t\tif (result)\n\t\t\t\t{\n\t\t\t\t\terrorCode = result.statusCode;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terrorCode = '-1';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog.debug('Connection %s ended', id);\n\t\t\t}\n\n\t\t\tvar elapsed = operation.latency.end(id, errorCode);\n\t\t\tif (elapsed < 0)\n\t\t\t{\n\t\t\t\t// not found or not running\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar index = operation.latency.getRequestIndex(id);\n\t\t\tif (result) {\n\t\t\t\tresult.requestElapsed = elapsed;\n\t\t\t\tresult.requestIndex = index;\n\t\t\t\tresult.instanceIndex = operation.instanceIndex;\n\t\t\t}\n\t\t\tvar callback;\n\t\t\tif (!params.requestsPerSecond)\n\t\t\t{\n\t\t\t\tcallback = self.makeRequest;\n\t\t\t}\n\t\t\toperation.callback(error, result, callback);\n\t\t};\n\t}\n\n\t/**\n\t * Get a function to connect the player.\n\t */\n\tfunction getConnect(id, callback)\n\t{\n\t\tvar body = '';\n\t\treturn function(connection)\n\t\t{\n\t\t\tlog.debug('HTTP client connected to %s with id %s', params.url, id);\n\t\t\tconnection.setEncoding('utf8');\n\t\t\tconnection.on('data', function(chunk)\n\t\t\t{\n\t\t\t\tlog.debug('Body: %s', chunk);\n\t\t\t\tbody += chunk;\n\t\t\t});\n\t\t\tconnection.on('error', function(error)\n\t\t\t{\n\t\t\t\tcallback('Connection ' + id + ' failed: ' + error, '1');\n\t\t\t});\n\t\t\tconnection.on('end', function()\n\t\t\t{\n\t\t\t\tvar result = {\n\t\t\t\t\thost: connection.connection._host,\n\t\t\t\t\tpath: connection.req.path,\n\t\t\t\t\tmethod: connection.req.method,\n\t\t\t\t\tstatusCode: connection.statusCode,\n\t\t\t\t\tbody: body,\n\t\t\t\t\theaders: connection.headers,\n\t\t\t\t};\n\t\t\t\tif (connection.statusCode >= 400)\n\t\t\t\t{\n\t\t\t\t\treturn callback('Status code ' + connection.statusCode, result);\n\t\t\t\t}\n\t\t\t\tcallback(null, result);\n\t\t\t});\n\t\t};\n\t}\n}\n\nfunction testHttpClient(callback)\n{\n\tvar options = {\n\t\turl: 'http://localhost:7357/',\n\t\tmaxSeconds: 0.1,\n\t\tconcurrency: 1,\n\t\tquiet: true,\n\t};\n\texports.create({}, options);\n\ttesting.success(callback);\n}\n\n\n/**\n * Run all tests.\n */\nexports.test = function(callback)\n{\n\ttesting.run([\n\t\ttestHttpClient,\n\t], callback);\n};\n\n// run tests if invoked directly\nif (__filename == process.argv[1])\n{\n\texports.test(testing.show);\n}\n\n","/home/travis/build/npmtest/node-npmtest-loadtest/loadtest/lib/timing.js":"'use strict';\n\n/**\n * Measure latency for a load test.\n * (C) 2013 Alex Fernández.\n */\n\n\n// requires\nrequire('prototypes');\nvar testing = require('testing');\nvar util = require('util');\nvar crypto = require('crypto');\nvar Log = require('log');\n\n// globals\nvar log = new Log('info');\n\n\n/**\n * Latency measurements. Options can be:\n *\t- maxRequests: max number of requests to measure before stopping.\n *\t- maxSeconds: max seconds, alternative to max requests.\n *\t- quiet: do not log messages.\n * An optional callback(error, results) will be called with an error,\n * or the results after max is reached.\n */\nexports.Latency = function(options, callback)\n{\n\t// self-reference\n\tvar self = this;\n\n\t// attributes\n\tvar requests = {};\n\tvar partialRequests = 0;\n\tvar partialTime = 0;\n\tvar partialErrors = 0;\n\tvar lastShown = getTime();\n\tvar initialTime = getTime();\n\tvar totalRequests = 0;\n\tvar totalTime = 0;\n\tvar totalErrors = 0;\n\tvar maxLatencyMs = 0;\n\tvar minLatencyMs = 999999;\n\tvar histogramMs = {};\n\tvar errorCodes = {};\n\tvar running = true;\n\tvar totalsShown = false;\n\n\tvar requestIndex = 0;\n\tvar requestIdToIndex = {};\n\n\t// init\n\tif (options.quiet)\n\t{\n\t\tlog.level = Log.NOTICE;\n\t}\n\tif (options.debug)\n\t{\n\t\tlog.level = Log.DEBUG;\n\t}\n\n\t/**\n\t * Return the index of the request. This is useful for determining the order\n\t * in which requests returned values.\n\t */\n\tself.getRequestIndex = function(requestId)\n\t{\n\t\treturn requestIdToIndex[requestId];\n\t};\n\n\t/**\n\t * Start the request with the given id.\n\t */\n\tself.start = function(requestId)\n\t{\n\t\trequestId = requestId || createId();\n\t\trequests[requestId] = getTime();\n\t\trequestIdToIndex[requestId] = requestIndex++;\n\t\treturn requestId;\n\t};\n\n\t/**\n\t * Compute elapsed time and add the measurement.\n\t * Accepts an optional error code signaling an error.\n\t */\n\tself.end = function(requestId, errorCode)\n\t{\n\t\tif (!(requestId in requests))\n\t\t{\n\t\t\tlog.debug('Message id ' + requestId + ' not found');\n\t\t\treturn -2;\n\t\t}\n\t\tif (!running)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\tvar elapsed = getElapsed(requests[requestId]);\n\t\tadd(elapsed, errorCode);\n\t\tdelete requests[requestId];\n\t\treturn elapsed;\n\t};\n\n\t/**\n\t * Add a new measurement, possibly removing an old one.\n\t * Accepts an optional error code signaling an error.\n\t */\n\tfunction add(time, errorCode)\n\t{\n\t\tlog.debug('New value: %s', time);\n\t\tpartialTime += time;\n\t\tpartialRequests++;\n\t\ttotalTime += time;\n\t\ttotalRequests++;\n\t\tif (errorCode)\n\t\t{\n\t\t\terrorCode = '' + errorCode;\n\t\t\tpartialErrors++;\n\t\t\ttotalErrors++;\n\t\t\tif (!(errorCode in errorCodes))\n\t\t\t{\n\t\t\t\terrorCodes[errorCode] = 0;\n\t\t\t}\n\t\t\terrorCodes[errorCode] += 1;\n\t\t}\n\t\tlog.debug('Partial requests: %s', partialRequests);\n\t\tvar rounded = Math.floor(time);\n\t\tif (rounded > maxLatencyMs)\n\t\t{\n\t\t\tmaxLatencyMs = rounded;\n\t\t}\n\t\tif (rounded < minLatencyMs)\n\t\t{\n\t\t\tminLatencyMs = rounded;\n\t\t}\n\t\tif (!histogramMs[rounded])\n\t\t{\n\t\t\tlog.debug('Initializing histogram for %s', rounded);\n\t\t\thistogramMs[rounded] = 0;\n\t\t}\n\t\thistogramMs[rounded] += 1;\n\t\tif (isFinished())\n\t\t{\n\t\t\tfinish();\n\t\t}\n\t}\n\n\t/**\n\t * Show latency for partial requests.\n\t */\n\tself.showPartial = function()\n\t{\n\t\tvar elapsedSeconds = getElapsed(lastShown) / 1000;\n\t\tvar meanTime = partialTime / partialRequests || 0.0;\n\t\tvar results = {\n\t\t\tmeanLatencyMs: Math.round(meanTime * 10) / 10,\n\t\t\trps: Math.round(partialRequests / elapsedSeconds)\n\t\t};\n\t\tvar percent = '';\n\t\tif (options.maxRequests)\n\t\t{\n\t\t\tpercent = ' (' + Math.round(100 * totalRequests / options.maxRequests) + '%)';\n\t\t}\n\t\tlog.info('Requests: %s%s, requests per second: %s, mean latency: %s ms', totalRequests, percent, results.rps, results.meanLatencyMs);\n\t\tif (totalErrors)\n\t\t{\n\t\t\tpercent = Math.round(100 * 10 * totalErrors / totalRequests) / 10;\n\t\t\tlog.info('Errors: %s, accumulated errors: %s, %s% of total requests', partialErrors, totalErrors, percent);\n\t\t}\n\t\tpartialTime = 0;\n\t\tpartialRequests = 0;\n\t\tpartialErrors = 0;\n\t\tlastShown = getTime();\n\t};\n\n\t/**\n\t * Returns the current high-resolution real time in a [seconds, nanoseconds] tuple Array\n\t * @return {*}\n\t */\n\tfunction getTime() {\n\t\treturn process.hrtime();\n\t}\n\n\t/**\n\t * calculates the elapsed time between the assigned startTime and now\n\t * @param startTime\n\t * @return {Number} the elapsed time in milliseconds\n\t */\n\tfunction getElapsed(startTime) {\n\t\tvar elapsed = process.hrtime(startTime);\n\t\treturn elapsed[0] * 1000 + elapsed[1] / 1000000;\n\t}\n\n\t/**\n\t * Check out if the measures are finished.\n\t */\n\tfunction isFinished()\n\t{\n\t\tlog.debug('Total requests %s, max requests: %s', totalRequests, options.maxRequests);\n\t\tif (options.maxRequests && totalRequests >= options.maxRequests)\n\t\t{\n\t\t\tlog.debug('Max requests reached: %s', totalRequests);\n\t\t\treturn true;\n\t\t}\n\t\tvar elapsedSeconds = getElapsed(initialTime) / 1000;\n\t\tif (options.maxSeconds && elapsedSeconds >= options.maxSeconds)\n\t\t{\n\t\t\tlog.debug('Max seconds reached: %s', totalRequests);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * We are finished.\n\t */\n\tfunction finish()\n\t{\n\t\trunning = false;\n\t\tif (callback)\n\t\t{\n\t\t\treturn callback(null, self.getResults());\n\t\t}\n\t\tself.show();\n\t}\n\n\t/**\n\t * Get final results.\n\t */\n\tself.getResults = function()\n\t{\n\t\tvar elapsedSeconds = getElapsed(initialTime) / 1000;\n\t\tvar meanTime = totalTime / totalRequests;\n\t\treturn {\n\t\t\ttotalRequests: totalRequests,\n\t\t\ttotalErrors: totalErrors,\n\t\t\ttotalTimeSeconds: elapsedSeconds,\n\t\t\trps: Math.round(totalRequests / elapsedSeconds),\n\t\t\tmeanLatencyMs: Math.round(meanTime * 10) / 10,\n\t\t\tmaxLatencyMs: maxLatencyMs,\n\t\t\tminLatencyMs: minLatencyMs,\n\t\t\tpercentiles: self.computePercentiles(),\n\t\t\terrorCodes: errorCodes\n\t\t};\n\t};\n\n\t/**\n\t * Compute the percentiles.\n\t */\n\tself.computePercentiles = function()\n\t{\n\t\tlog.debug('Histogram: %s', util.inspect(histogramMs));\n\t\tvar percentiles = {\n\t\t\t50: false,\n\t\t\t90: false,\n\t\t\t95: false,\n\t\t\t99: false\n\t\t};\n\t\tvar counted = 0;\n\n\t\tfor (var ms = 0; ms <= maxLatencyMs; ms++)\n\t\t{\n\t\t\tif (!histogramMs[ms])\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlog.debug('Histogram for %s: %s', ms, histogramMs[ms]);\n\t\t\tcounted += histogramMs[ms];\n\t\t\tvar percent = counted / totalRequests * 100;\n\n\t\t\tObject.keys(percentiles).forEach(function(percentile) {\n\t\t\t\tlog.debug('Checking percentile %s for %s', percentile, percent);\n\t\t\t\tif (!percentiles[percentile] && percent > percentile)\n\t\t\t\t{\n\t\t\t\t\tpercentiles[percentile] = ms;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn percentiles;\n\t};\n\n\t/**\n\t * Show final results.\n\t */\n\tself.show = function()\n\t{\n\t\tif (totalsShown)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\ttotalsShown = true;\n\t\tvar results = self.getResults();\n\t\tlog.info('');\n\t\tlog.info('Target URL:          %s', options.url);\n\t\tif (options.maxRequests)\n\t\t{\n\t\t\tlog.info('Max requests:        %s', options.maxRequests);\n\t\t}\n\t\telse if (options.maxSeconds)\n\t\t{\n\t\t\tlog.info('Max time (s):        %s', options.maxSeconds);\n\t\t}\n\t\tlog.info('Concurrency level:   %s', options.concurrency);\n\t\tvar agent = 'none';\n\t\tif (options.agentKeepAlive)\n\t\t{\n\t\t\tagent = 'keepalive';\n\t\t}\n\t\tlog.info('Agent:               %s', agent);\n\t\tif (options.requestsPerSecond)\n\t\t{\n\t\t\tlog.info('Requests per second: %s', options.requestsPerSecond * options.concurrency);\n\t\t}\n\t\tlog.info('');\n\t\tlog.info('Completed requests:  %s', results.totalRequests);\n\t\tlog.info('Total errors:        %s', results.totalErrors);\n\t\tlog.info('Total time:          %s s', results.totalTimeSeconds);\n\t\tlog.info('Requests per second: %s', results.rps);\n\t\tlog.info('Mean latency:        %s ms', results.meanLatencyMs);\n\t\tlog.info('');\n\t\tlog.info('Percentage of the requests served within a certain time');\n\n\t\tObject.keys(results.percentiles).forEach(function(percentile) {\n\t\t\tlog.info('  %s%      %s ms', percentile, results.percentiles[percentile]);\n\t\t});\n\n\t\tlog.info(' 100%      %s ms (longest request)', maxLatencyMs);\n\t\tif (results.totalErrors)\n\t\t{\n\t\t\tlog.info('');\n\t\t\tlog.info(' 100%      %s ms (longest request)', maxLatencyMs);\n\t\t\tlog.info('');\n\t\t\tObject.keys(results.errorCodes).forEach(function(errorCode)\n\t\t\t{\n\t\t\t\tvar padding = ' '.repeat(4 - errorCode.length);\n\t\t\t\tlog.info(' %s%s:   %s errors', padding, errorCode, results.errorCodes[errorCode]);\n\t\t\t});\n\t\t}\n\t};\n};\n\n\n/**\n * Create a unique, random token.\n */\nfunction createId()\n{\n\tvar value = '' + Date.now() + Math.random();\n\tvar hash = crypto.createHash('sha256');\n\treturn hash.update(value).digest('hex').toLowerCase();\n}\n\n/**\n * Test latency ids.\n */\nfunction testLatencyIds(callback)\n{\n\tvar latency = new exports.Latency({});\n\tvar firstId = latency.start();\n\ttesting.assert(firstId, 'Invalid first latency id %s', firstId, callback);\n\tvar secondId = latency.start();\n\ttesting.assert(secondId, 'Invalid second latency id', callback);\n\ttesting.assert(firstId != secondId, 'Repeated latency ids', callback);\n\ttesting.success(callback);\n}\n\n/**\n * Test latency measurements.\n */\nfunction testLatencyRequests(callback)\n{\n\tvar options = {\n\t\tmaxRequests: 10,\n\t};\n\tvar errorCode = '500';\n\tvar latency = new exports.Latency(options, function(error, result)\n\t{\n\t\ttesting.check(error, 'Could not compute latency', callback);\n\t\ttesting.assertEquals(result.totalRequests, 10, 'Invalid total requests', callback);\n\t\ttesting.assertEquals(result.totalErrors, 1, 'Invalid total errors', callback);\n\t\ttesting.assert(errorCode in result.errorCodes, 'Error code not found', callback);\n\t\ttesting.assertEquals(result.errorCodes[errorCode], 1, 'Should have one ' + errorCode, callback);\n\t\ttesting.success(callback);\n\t});\n\tvar id;\n\tfor (var i = 0; i < 9; i++)\n\t{\n\t\tid = latency.start();\n\t\tlatency.end(id);\n\t}\n\tid = latency.start();\n\tlatency.end(id, errorCode);\n}\n\n/**\n * Check that percentiles are correct.\n */\nfunction testLatencyPercentiles(callback)\n{\n\tvar options = {\n\t\tmaxRequests: 10\n\t};\n\tvar latency = new exports.Latency(options, function(error)\n\t{\n\t\ttesting.check(error, 'Error while testing latency percentiles', callback);\n\t\tvar percentiles = latency.getResults().percentiles;\n\n\t\tObject.keys(percentiles).forEach(function(percentile) {\n\t\t\ttesting.assert(percentiles[percentile] !== false, 'Empty percentile for %s', percentile, callback);\n\t\t});\n\n\t\ttesting.success(percentiles, callback);\n\t});\n\tfor (var ms = 1; ms <= 10; ms++)\n\t{\n\t\tlog.debug('Starting %s', ms);\n\t\t(function() {\n\t\t\tvar id = latency.start();\n\t\t\tsetTimeout(function()\n\t\t\t{\n\t\t\t\tlog.debug('Ending %s', id);\n\t\t\t\tlatency.end(id);\n\t\t\t}, ms);\n\t\t})();\n\t}\n}\n\n/**\n * A high resolution timer. Params:\n *\t- delayMs: miliseconds to wait before calls. Can be fractional.\n *\t- callback: function to call every time.\n */\nexports.HighResolutionTimer = function(delayMs, callback)\n{\n\t// self-reference\n\tvar self = this;\n\n\t// attributes\n\tvar counter = 0;\n\tvar start = Date.now();\n\tvar active = true;\n\tvar timer;\n\n\t/**\n\t * Delayed running of the callback.\n\t */\n\tfunction delayed()\n\t{\n\t\tif (!active)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tcallback();\n\t\tcounter ++;\n\t\tvar diff = (Date.now() - start) - counter * delayMs;\n\t\tvar timeout = Math.floor(delayMs - diff);\n\t\tif (timeout <= 0)\n\t\t{\n\t\t\treturn delayed();\n\t\t}\n\t\ttimer = setTimeout(delayed, delayMs - diff);\n\t}\n\n\t/**\n\t * Show the drift of the timer.\n\t */\n\tself.traceDrift = function()\n\t{\n\t\tvar diff = Date.now() - start;\n\t\tvar drift = diff / delayMs - counter;\n\t\tlog.debug('Seconds: ' + Math.round(diff / 1000) + ', counter: ' + counter + ', drift: ' + drift);\n\t};\n\n\t/**\n\t * Stop the timer.\n\t */\n\tself.stop = function()\n\t{\n\t\tactive = false;\n\t\tif (timer)\n\t\t{\n\t\t\tclearTimeout(timer);\n\t\t\ttimer = null;\n\t\t}\n\t};\n\n\t// start timer\n\tdelayed();\n\ttimer = setTimeout(delayed, delayMs);\n};\n\n/**\n * Test a high resolution timer.\n */\nfunction testTimer(callback)\n{\n\tvar timer = new exports.HighResolutionTimer(10, callback);\n\ttimer.stop();\n}\n\n/**\n * Run package tests.\n */\nexports.test = function(callback)\n{\n\tvar tests = [\n\t\ttestLatencyIds,\n\t\ttestLatencyRequests,\n\t\ttestLatencyPercentiles,\n\t\ttestTimer\n\t];\n\ttesting.run(tests, callback);\n};\n\n// run tests if invoked directly\nif (__filename == process.argv[1])\n{\n\texports.test(testing.show);\n}\n\n","/home/travis/build/npmtest/node-npmtest-loadtest/loadtest/lib/headers.js":"'use strict';\n\n/**\n * Support for custom headers.\n * (C) 2013 Alex Fernández.\n */\n\n// requires\nrequire('prototypes');\nvar testing = require('testing');\n\n\n/**\n * Add all raw headers given to the given array.\n */\nexports.addHeaders = function(rawHeaders, headers)\n{\n\tif (Array.isArray(rawHeaders))\n\t{\n\t\trawHeaders.forEach(function(header)\n\t\t{\n\t\t\taddHeader(header, headers);\n\t\t});\n\t}\n\telse if (typeof rawHeaders == 'string')\n\t{\n\t\taddHeader(rawHeaders, headers);\n\t}\n\telse\n\t{\n\t\tconsole.error('Invalid header structure %j, it should be an array');\n\t}\n};\n\n/**\n * Add a single header to an array.\n */\nfunction addHeader(rawHeader, headers)\n{\n\tif (!rawHeader.contains(':'))\n\t{\n\t\treturn console.error('Invalid header %s, it should be in the form -H key:value');\n\t}\n\tvar index = rawHeader.indexOf(':');\n\tvar key = rawHeader.substr(0, index);\n\tvar value = rawHeader.substr(index + 1);\n\theaders[key.toLowerCase()] = value;\n}\n\nfunction testAddHeaders(callback)\n{\n\tvar tests = [\n\t\t{\n\t\t\traw: 'k:v',\n\t\t\theaders: { 'k': 'v' }\n\t\t},\n\t\t{\n\t\t\traw: ['k:v', 'k:v2'],\n\t\t\theaders:  { 'k': 'v2' }\n\t\t},\n\t\t{\n\t\t\traw: ['k:v', 'k2:v2'],\n\t\t\theaders: { 'k': 'v', 'k2': 'v2' }\n\t\t},\n\t\t{\n\t\t\traw: 'K:v',\n\t\t\theaders: { 'k': 'v' }\n\t\t},\n\t\t{\n\t\t\traw: 'k:v:w',\n\t\t\theaders: { 'k': 'v:w' }\n\t\t}\n\t];\n\ttests.forEach(function(test)\n\t{\n\t\tvar headers = {};\n\t\texports.addHeaders(test.raw, headers);\n\t\ttesting.assertEquals(headers, test.headers, 'Wrong headers', callback);\n\t});\n\ttesting.success(callback);\n}\n\n/**\n * Add a user-agent header if not present.\n */\nexports.addUserAgent = function(headers)\n{\n\tif(!headers['user-agent'])\n\t{\n\t  headers['user-agent'] = 'node.js loadtest bot';\n\t}\n};\n\nfunction testAddUserAgent(callback)\n{\n\tvar headers =  {'k': 'v', 'q': 'r' };\n\texports.addUserAgent(headers);\n\ttesting.assertEquals(Object.keys(headers).length, 3, 'Did not add user agent', callback);\n\tvar userAgent = headers['user-agent'];\n\ttesting.assert(userAgent.contains('bot'), 'Invalid user agent', callback);\n\texports.addUserAgent(headers);\n\ttesting.assertEquals(Object.keys(headers).length, 3, 'Should not add user agent', callback);\n\ttesting.success(callback);\n}\n\n/**\n * Run all tests.\n */\nexports.test = function(callback)\n{\n\ttesting.run([\n\t\ttestAddHeaders,\n\t\ttestAddUserAgent,\n\t], callback);\n};\n\n// run tests if invoked directly\nif (__filename == process.argv[1])\n{\n\texports.test(testing.show);\n}\n\n","/home/travis/build/npmtest/node-npmtest-loadtest/loadtest/lib/websocket.js":"'use strict';\n\n/**\n * Load test a websocket.\n * (C) 2013 Alex Fernández.\n */\n\n\n// requires\nrequire('prototypes');\nvar WebSocketClient = require('websocket').client;\nvar testing = require('testing');\nvar Log = require('log');\nvar BaseClient = require('./baseClient.js').BaseClient;\n\n// globals\nvar log = new Log('debug');\nvar latency;\n\n\n/**\n * Create a client for a websocket.\n */\nexports.create = function(operation, params)\n{\n\treturn new WebsocketClient(operation, params);\n};\n\n/**\n * A client that connects to a websocket.\n */\nvar WebsocketClient = function(operation, params)\n{\n\tBaseClient.call(this, operation, params);\n\n\t// self-reference\n\tvar self = this;\n\n\t// attributes\n\tvar connection;\n\tvar lastCall;\n\n\tself.client = null;\n\n\tthis.init();\n\n\t/**\n\t * Start the websocket client.\n\t */\n\tself.start = function()\n\t{\n\t\tself.client = new WebSocketClient();\n\t\tself.client.on('connectFailed', function(error) {\n\t\t\tlog.debug('WebSocket client connection error ' + error);\n\t\t});\n\t\tself.client.on('connect', connect);\n\t\tself.client.connect(params.url, []);\n\t\tlog.debug('WebSocket client connected to ' + params.url);\n\t};\n\n\n\tself.startRequests = function()\n\t{\n\t\treturn self.makeRequest();\n\t};\n\n\t/**\n\t * Stop the websocket client.\n\t */\n\tself.stop = function()\n\t{\n\t\tif (connection)\n\t\t{\n\t\t\tconnection.close();\n\t\t\tlog.debug('WebSocket client disconnected from ' + params.url);\n\t\t}\n\t};\n\n\t/**\n\t * Connect the player.\n\t */\n\tfunction connect(localConnection)\n\t{\n\t\tconnection = localConnection;\n\n\t\tself.startRequests();\n\t}\n\n\t/**\n\t * Make a single request to the server.\n\t */\n\tself.makeRequest = function()\n\t{\n\t\tvar id = operation.latency.start(id);\n\t\tvar requestFinished = self.getRequestFinisher(id);\n\n\t\tif (connection.connected)\n\t\t{\n\t\t\tvar ended = false;\n\n\n\t\t\t// NOTE: there are no per-request callbacks (and no notion of request/response)\n\t\t\t// in the websockets package.  So we can't support requestsPerSecond; everythinng must\n\t\t\t// be synchronous per connection.\n\n\t\t\tconnection.on('error', function(error) {\n\t\t\t\tif (ended) return;\n\t\t\t\tended = true;\n\t\t\t\trequestFinished('Connection error: ' + error);\n\t\t\t});\n\n\t\t\tconnection.on('close', function() {\n\t\t\t\tif (ended) return;\n\t\t\t\tended = true;\n\t\t\t\trequestFinished('Connection closed ');\n\t\t\t});\n\n\t\t\tconnection.on('message', function(message) {\n\t\t\t\tif (ended) return;\n\t\t\t\tended = true;\n\n\t\t\t\tif (message.type != 'utf8')\n\t\t\t\t{\n\t\t\t\t\tlog.error('Invalid message type ' + message.type);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar json;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tjson = JSON.parse(message.utf8Data);\n\t\t\t\t}\n\t\t\t\tcatch(e)\n\t\t\t\t{\n\t\t\t\t\tlog.error('Invalid JSON: ' + message.utf8Data);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlog.debug(\"Received response %j\", json);\n\n\t\t\t\t// eat the client_connected message we get at the beginning\n\t\t\t\tif ((json && json[0] && json[0][0] == 'client_connected')) {\n\t\t\t\t\tended = false;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (lastCall)\n\t\t\t\t{\n\t\t\t\t\tvar newCall = new Date().getTime();\n\t\t\t\t\tlatency.add(newCall - lastCall);\n\t\t\t\t\tlog.debug('latency: ' + (newCall - lastCall));\n\t\t\t\t\tlastCall = null;\n\t\t\t\t}\n\n\t\t\t\trequestFinished(null, json);\n\t\t\t});\n\n\t\t\tvar message;\n\n\t\t\tif (self.generateMessage)\n\t\t\t{\n\t\t\t\tmessage = self.generateMessage(id);\n\t\t\t}\n\t\t\tif (typeof params.requestGenerator == 'function')\n\t\t\t{\n\t\t\t\t// create a 'fake' object which can function like the http client\n\t\t\t\tvar req = function() {\n\t\t\t\t\treturn {\n\t\t\t\t\t\twrite: function(message) {\n\t\t\t\t\t\t\tconnection.sendUTF(message);\n\t\t\t\t\t\t} \n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\tparams.requestGenerator(self.params, self.options, req, requestFinished);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tconnection.sendUTF(JSON.stringify(message));\n\t\t\t}\n\t\t}\n\t};\n};\n\n\nWebsocketClient.prototype = Object.create(BaseClient.prototype);\nWebsocketClient.prototype.constructor = WebsocketClient;\n\nWebsocketClient.prototype.init = function()\n{\n    Object.getPrototypeOf(this.constructor.prototype).init.call(this);\n};\n\nfunction testWebsocketClient(callback)\n{\n\tvar options = {\n\t\turl: 'ws://localhost:7357/',\n\t\tmaxSeconds: 0.1,\n\t\tconcurrency: 1,\n\t\tquiet: true,\n\t};\n\texports.create({}, options);\n\ttesting.success(callback);\n}\n\n/**\n * Run tests, currently nothing.\n */\nexports.test = function(callback)\n{\n\ttesting.run([\n\t\ttestWebsocketClient,\n\t], callback);\n};\n\n// start tests if invoked directly\nif (__filename == process.argv[1])\n{\n\texports.test(testing.show);\n}\n\n","/home/travis/build/npmtest/node-npmtest-loadtest/loadtest/lib/baseClient.js":"\"use strict\";\n\nvar urlLib = require('url');\nvar Log = require('log');\nvar headers = require('./headers.js');\n\n// globals\nvar log = new Log('debug');\n\n\nmodule.exports.BaseClient = function(operation, params)\n{\n\tthis.operation = operation;\n\tthis.params = params;\n\tthis.generateMessage = undefined;\n};\n\n/**\n * Get a function that finishes one request and goes for the next.\n */\nmodule.exports.BaseClient.prototype.getRequestFinisher = function(id)\n{\n\tvar self = this;\n\n\treturn function(error, result)\n\t{\n\t\tvar errorCode = null;\n\t\tif (error)\n\t\t{\n\t\t\tlog.debug('Connection %s failed: %s', id, error);\n\t\t\tif (result)\n\t\t\t{\n\t\t\t\terrorCode = result;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\terrorCode = '-1';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog.debug('Connection %s ended', id);\n\t\t}\n\t\tself.operation.latency.end(id, errorCode);\n\t\tvar callback;\n\t\tif (!self.params.requestsPerSecond)\n\t\t{\n\t\t\tcallback = self.makeRequest;\n\t\t}\n\t\tself.operation.callback(error, result, callback);\n\t};\n};\n\n\n/**\n * Init options and message to send.\n */\nmodule.exports.BaseClient.prototype.init = function()\n{\n\tfunction identity(arg)\n\t{\n\t\treturn function() { return arg; };\n\t}\n\n\tthis.options = urlLib.parse(this.params.url);\n\tthis.options.headers = {};\n\tif (this.params.headers)\n\t{\n\t\tthis.options.headers = this.params.headers;\n\t}\n\tif (this.params.cert && this.params.key)\n\t{\n\t\tthis.options.cert = this.params.cert;\n\t\tthis.options.key = this.params.key;\n\t}\n\tthis.options.agent = false;\n\tif (this.params.body)\n\t{\n\t\tif (typeof this.params.body == 'string')\n\t\t{\n\t\t\tlog.debug('Received string body');\n\t\t\tthis.generateMessage = identity(this.params.body);\n\t\t}\n\t\telse if (typeof this.params.body == 'object')\n\t\t{\n\t\t\tlog.debug('Received JSON body');\n\t\t\tthis.generateMessage = identity(this.params.body);\n\t\t}\n\t\telse if (typeof this.params.body == 'function')\n\t\t{\n\t\t\tlog.debug('Received function body');\n\t\t\tthis.generateMessage = this.params.body;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog.error('Unrecognized body: %s', typeof this.params.body);\n\t\t}\n\t\tthis.options.headers['Content-Type'] = this.params.contentType || 'text/plain';\n\t}\n\theaders.addUserAgent(this.options.headers);\n\tif (this.params.secureProtocol) {\n\t\tthis.options.secureProtocol = this.params.secureProtocol;\n\t}\n\tlog.debug('Options: %j',this.options);\n};\n\n","/home/travis/build/npmtest/node-npmtest-loadtest/loadtest/lib/testserver.js":"'use strict';\n\n/**\n * Test server to load test.\n * (C) 2013 Alex Fernández.\n */\n\n\n// requires\nrequire('prototypes');\nvar testing = require('testing');\nvar http = require('http');\nvar WebSocketServer = require('websocket').server;\nvar util = require('util');\nvar net = require('net');\nvar Log = require('log');\nvar timing = require('./timing.js');\n\n// globals\nvar log = new Log('debug');\n\n// constants\nvar PORT = 7357;\nvar LOG_HEADERS_INTERVAL_SECONDS = 1;\n\n\n/**\n * A test server, with the given options (see below on startServer()).\n */\nfunction TestServer(options)\n{\n\t// self-reference\n\tvar self = this;\n\n\t// attributes\n\tvar port = options.port || PORT;\n\tvar server, wsServer;\n\tvar latency = new timing.Latency({});\n\tvar debuggedTime = Date.now();\n\n\t// init\n\tif (options.quiet)\n\t{\n\t\tlog.level = 'notice';\n\t}\n\t\n\t/**\n\t * Start the server.\n\t * An optional callback will be called after the server has started.\n\t */\n\tself.start = function(callback)\n\t{\n\t\tif (options.socket)\n\t\t{\n\t\t\t// just for internal debugging\n\t\t\tserver = net.createServer(socketListen);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tserver = http.createServer(listen);\n\n\t\t\twsServer = new WebSocketServer({\n\t\t\thttpServer: server,\n\t\t\tautoAcceptConnections: false // OK only because this is for testing only\n\t\t\t});\n\t\t}\n\t\tserver.on('error', function(error)\n\t\t{\n\t\t\tif (error.code == 'EADDRINUSE')\n\t\t\t{\n\t\t\t\treturn createError('Port ' + port + ' in use, please free it and retry again', callback);\n\t\t\t}\n\t\t\treturn createError('Could not start server on port ' + port + ': ' + error, callback);\n\t\t});\n\t\tserver.listen(port, function()\n\t\t{\n\t\t\tlog.info('Listening on port %s', port);\n\t\t\tif (callback)\n\t\t\t{\n\t\t\t\tcallback();\n\t\t\t}\n\t\t});\n\t\twsServer.on('request', function(request)\n\t\t{\n\t\t\t// explicity omitting origin check here.\n\t\t\tvar connection = request.accept(null, request.origin);\n\t\t\tlog.debug(' Connection accepted.');\n\t\t\tconnection.on('message', function(message)\n\t\t\t{\n\t\t\t\tif (message.type === 'utf8')\n\t\t\t\t{\n\t\t\t\t\tlog.debug('Received Message: ' + message.utf8Data);\n\t\t\t\t\tconnection.sendUTF(message.utf8Data);\n\t\t\t\t}\n\t\t\t\telse if (message.type === 'binary')\n\t\t\t\t{\n\t\t\t\t\tlog.debug('Received Binary Message of ' + message.binaryData.length + ' bytes');\n\t\t\t\t\tconnection.sendBytes(message.binaryData);\n\t\t\t\t}\n\t\t\t});\n\t\t\tconnection.on('close', function()\n\t\t\t{\n\t\t\t\tlog.info('Peer %s disconnected', connection.remoteAddress);\n\t\t\t});\n\t\t});\n\t\treturn server;\n\t};\n\n\t/**\n\t * Log an error, or send to the callback if present.\n\t */\n\tfunction createError(message, callback)\n\t{\n\t\tif (!callback)\n\t\t{\n\t\t\treturn log.error(message);\n\t\t}\n\t\tcallback(message);\n\t}\n\n\t/**\n\t * Listen to an incoming request.\n\t */\n\tfunction listen(request, response)\n\t{\n\t\tvar id = latency.start();\n\t\trequest.body = '';\n\t\trequest.on('data', function(data)\n\t\t{\n\t\t\trequest.body += data.toString();\n\t\t});\n\t\trequest.on('end', function()\n\t\t{\n\t\t\tvar now = Date.now();\n\t\t\tif (now - debuggedTime > LOG_HEADERS_INTERVAL_SECONDS * 1000)\n\t\t\t{\n\t\t\t\tdebug(request);\n\t\t\t\tdebuggedTime = now;\n\t\t\t}\n\t\t\tif (!options.delay)\n\t\t\t{\n\t\t\t\treturn end(response, id);\n\t\t\t}\n\t\t\tsetTimeout(function()\n\t\t\t{\n\t\t\t\tend(response, id);\n\t\t\t}, options.delay);\n\t\t});\n\t}\n\n\t/**\n\t * Listen on a socket.\n\t */\n\tfunction socketListen(socket)\n\t{\n\t\tsocket.on('error', function(error)\n\t\t{\n\t\t\tlog.error('socket error: %s', error);\n\t\t\tsocket.end();\n\t\t});\n\t\tsocket.on('data', readData);\n\t}\n\n\t/**\n\t * Read some data off the socket.\n\t */\n\tfunction readData(data)\n\t{\n\t\tlog.info('data: %s', data);\n\t}\n\n\t/**\n\t * Debug headers and other interesting information: POST body.\n\t */\n\tfunction debug(request)\n\t{\n\t\tlog.info('Headers for %s to %s: %s', request.method, request.url, util.inspect(request.headers));\n\t\tif (request.body)\n\t\t{\n\t\t\tlog.info('Body: %s', request.body);\n\t\t}\n\t}\n\n\t/**\n\t * End the response now.\n\t */\n\tfunction end(response, id)\n\t{\n\t\tif (shouldError())\n\t\t{\n\t\t\tvar code = options.error || 500;\n\t\t\tresponse.writeHead(code);\n\t\t\tresponse.end('ERROR');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresponse.end('OK');\n\t\t}\n\t\tlatency.end(id);\n\t}\n\n\tfunction shouldError()\n\t{\n\t\tif (!options.percent)\n\t\t{\n\t\t\tif (options.error)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tvar percent = parseInt(options.percent, 10);\n\t\tif (!percent)\n\t\t{\n\t\t\tlog.error('Invalid error percent %s', options.percent);\n\t\t\treturn false;\n\t\t}\n\t\treturn (Math.random() < percent / 100);\n\t}\n}\n\n/**\n * Start a test server. Options can contain:\n *\t- port: the port to use, default 7357.\n *\t- delay: wait the given milliseconds before answering.\n *\t- quiet: do not log any messages.\n *\t- percent: give an error (default 500) on some % of requests.\n *\t- error: set an HTTP error code, default is 500.\n * An optional callback is called after the server has started.\n * In this case the quiet option is enabled.\n */\nexports.startServer = function(options, callback)\n{\n\tif (callback)\n\t{\n\t\toptions.quiet = true;\n\t}\n\tvar server = new TestServer(options);\n\treturn server.start(callback);\n};\n\nfunction testStartServer(callback)\n{\n\tvar options = {\n\t\tport: 10530,\n\t};\n\tvar server = exports.startServer(options, function(error)\n\t{\n\t\ttesting.check(error, 'Could not start server', callback);\n\t\tserver.close(function(error)\n\t\t{\n\t\t\ttesting.check(error, 'Could not stop server', callback);\n\t\t\ttesting.success(callback);\n\t\t});\n\t});\n}\n\n/**\n * Run the tests.\n */\nexports.test = function(callback)\n{\n\ttesting.run([testStartServer], 5000, callback);\n};\n\n// start server if invoked directly\nif (__filename == process.argv[1])\n{\n\texports.test(testing.show);\n}\n\n"}